---
layout:     post
title:      "SOLID? OCP"
subtitle:   ""
date:       2019-02-16 12:00:00
author:     "Nekisse"
header-img: "img/post-bg-02.jpg"
---
 


# Open Closed Principle (개방폐쇄원칙)

 - 확장에 대해서는 열려있고 변경에 대해서는 닫혀있다.
   - 새로운 타입을 추가함으로써 새로운 기능을 추가할 수 있다.(확장)
   
 - 확장이 일어날때 상위레벨이 영향을 받지 말아야 한다.
 - 모듈의 행위를 쉽게 변경할 수 있다, 소스코드 수정하지 않고도
 


# 그런데
- 새로운 기능을 요구하면 대책이 없다.  
아무도 이런 얘길 해주지 않아서다.  
***만일 미리 얘기해줬다면*** 이런 요구사항을 수용할 수 있도록  
**Abstraction을 적용했을 것**이다.  
**내가 미리 알았더라면**  
새로운 기능을 수정없이 확장할 수 있도록 OCP를 준수하도록  
설계했을 것이다.  
OCP는 앞으로 어떤 확장이 필요할 지 알아야 제대로 할 수 있다는말인가?

- 아무리 잘 찾고, 잘 예측해도 고객은  
반드시 당신이 준비하지 못한 것에 대한 기능 추가/변경을 요구 한다. -Unknown Unknowns

- OCP, OOD는 당신이 미래를 예측할 수 있을때만 해당 기능을 보호할 수 있다.

# 해결법
## Big design Up Front(BDUF) 치밀한 설계
- 조심스럽게 고객과 문제영역을 고찰한다. (그런데 고객은 뭘 원하는지 잘모를 수 있다.
하지말라는건 아니지만 너무 많이 할 필요는...)
- 고객의 요구사을 예측하여 도메인 모델을 만든다.
- OCP가 가능하도록 도메인 모델에 추상화를 적용한다.
- 변경될 가능성이 있는 모든 것들에 대한 청사진을 얻을 때까지 헛된 짓을 계속한다.

### 문제
- 대부분의 경우 필요치 않는 추상화로 도배된 매우 크고, 무겁고 복잡한 쓰레기 설계를 만든다.
- 추상화는 유용하고 강력한 대신 비용도 크다.

# 해결법2
## Agile Design
- 변화에 대한 가장 좋은 에쳬그은 변화를 경험하는 것
- 모든 종류의 변경을 완벽하게 예측하고 이에 대한 변경에 대응하기 위해  
Abstraction을 적용하는 대신,  
고객이 변경을 요구할 때까지 기다리고 Abstraction을 만들어서 향후  
추가적으로 재발하는 변화로 부터 보호될 수 있도록 해라.
- 고객이 변경을 요구하면 Agile Designer는 코드를 **리팩토링**해서  
그런 종류의 변경을 쉽게할 수 있도록 Abstraction을 추가한다.  
OCP를 준수하도록.. 

- 최대한 빨리 고객의 요구사항을 끌어낼 수 있는 가장 단순한 일을 한다.
- 그럼 고객은 그 결과물에 대해 요구사항 변경을 시작한다.
- 그럼 어떤 변경이 요구되는지 알게된다.

### Agile Design in Practice
- BDUF (과도한(치밀한)설계)도 피해야하지만 NO DUF도 피해야한다.
- 시스템의 기본모양을 수립하는 것이지  
모든 작은 상세까지 수립하는 것은 아니다.
- 문제에 대해서 과하게 생각하면 유지보수 비용이 높은  
많은 불필요환 추상화를 만들게 된다.
- **빨리 자주 Deliver(전달)** 하고 **고객의 요구사항 변화에 기반하여 리팩토링** 하는 것
- 이럴때 **OCP가 진가** 를 발휘한다.
- 하지만 **간단한 도메인 없이 이렇게 진행하면 방향성 없는 혼란한 구조를 유발**한다.

